// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type FakeObject struct {
	DeepCopyObjectStub        func() runtime.Object
	deepCopyObjectMutex       sync.RWMutex
	deepCopyObjectArgsForCall []struct {
	}
	deepCopyObjectReturns struct {
		result1 runtime.Object
	}
	deepCopyObjectReturnsOnCall map[int]struct {
		result1 runtime.Object
	}
	GetObjectKindStub        func() schema.ObjectKind
	getObjectKindMutex       sync.RWMutex
	getObjectKindArgsForCall []struct {
	}
	getObjectKindReturns struct {
		result1 schema.ObjectKind
	}
	getObjectKindReturnsOnCall map[int]struct {
		result1 schema.ObjectKind
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeObject) DeepCopyObject() runtime.Object {
	fake.deepCopyObjectMutex.Lock()
	ret, specificReturn := fake.deepCopyObjectReturnsOnCall[len(fake.deepCopyObjectArgsForCall)]
	fake.deepCopyObjectArgsForCall = append(fake.deepCopyObjectArgsForCall, struct {
	}{})
	fake.recordInvocation("DeepCopyObject", []interface{}{})
	fake.deepCopyObjectMutex.Unlock()
	if fake.DeepCopyObjectStub != nil {
		return fake.DeepCopyObjectStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deepCopyObjectReturns
	return fakeReturns.result1
}

func (fake *FakeObject) DeepCopyObjectCallCount() int {
	fake.deepCopyObjectMutex.RLock()
	defer fake.deepCopyObjectMutex.RUnlock()
	return len(fake.deepCopyObjectArgsForCall)
}

func (fake *FakeObject) DeepCopyObjectCalls(stub func() runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = stub
}

func (fake *FakeObject) DeepCopyObjectReturns(result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	fake.deepCopyObjectReturns = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *FakeObject) DeepCopyObjectReturnsOnCall(i int, result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	if fake.deepCopyObjectReturnsOnCall == nil {
		fake.deepCopyObjectReturnsOnCall = make(map[int]struct {
			result1 runtime.Object
		})
	}
	fake.deepCopyObjectReturnsOnCall[i] = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *FakeObject) GetObjectKind() schema.ObjectKind {
	fake.getObjectKindMutex.Lock()
	ret, specificReturn := fake.getObjectKindReturnsOnCall[len(fake.getObjectKindArgsForCall)]
	fake.getObjectKindArgsForCall = append(fake.getObjectKindArgsForCall, struct {
	}{})
	fake.recordInvocation("GetObjectKind", []interface{}{})
	fake.getObjectKindMutex.Unlock()
	if fake.GetObjectKindStub != nil {
		return fake.GetObjectKindStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getObjectKindReturns
	return fakeReturns.result1
}

func (fake *FakeObject) GetObjectKindCallCount() int {
	fake.getObjectKindMutex.RLock()
	defer fake.getObjectKindMutex.RUnlock()
	return len(fake.getObjectKindArgsForCall)
}

func (fake *FakeObject) GetObjectKindCalls(stub func() schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = stub
}

func (fake *FakeObject) GetObjectKindReturns(result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	fake.getObjectKindReturns = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *FakeObject) GetObjectKindReturnsOnCall(i int, result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	if fake.getObjectKindReturnsOnCall == nil {
		fake.getObjectKindReturnsOnCall = make(map[int]struct {
			result1 schema.ObjectKind
		})
	}
	fake.getObjectKindReturnsOnCall[i] = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *FakeObject) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deepCopyObjectMutex.RLock()
	defer fake.deepCopyObjectMutex.RUnlock()
	fake.getObjectKindMutex.RLock()
	defer fake.getObjectKindMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeObject) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ runtime.Object = new(FakeObject)
